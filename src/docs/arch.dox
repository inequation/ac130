/**
\page arch Architecture
\section startp Starting points
This isn't the first game I have written and as such I already had a pretty good
idea about what to do and what not to do. Thus, I had a few key, even though
mostly unrelated, design points in mind from the very beginning:
-	\b Modularity \b on \b different \b levels. In my opinion, it's one of the
	most important features of a good game engine. For instance, it is
	unnaceptable for the game logic code to make any OpenGL or any other library
	calls - the engine and the game logic must be separated, with just an
	abstraction layer exposed to the game mechanics code. Also, any pieces of
	code that form a more or less self-contained unit should be put into a
	separate module (source code file) for cleaner design and overall better
	organisation of the source tree.
-	\b SSE \b instructions \b utilization. Modern CPUs provide SIMD (Single
	Instruction, Multiple Data) vector instructions for fast floating point
	vector calculations. Since the game, as a 3D application, would be heavily
	reliant on vector math, and I hadn't used SSE before yet, I figured it would
	be a great opportunity to learn, while also providing a boost in
	performance.
-	\b Cross-platformness. I'm an open source advocate, my platform of choice is
	Linux, therefore the choice to write the application in such a way so that
	the same code can compile and work on different platforms was only natural.
-	\b Procedural \b content \b generation. Being a programmer and not a skilled
	artist, content creation would probably the most frustrating part of the
	development process. I decided to skip it by providing algorithms to do the
	work. It also has the upsides of the fun to be had from designing these
	formulas and remarkably small final package size.
-	A point implied by the previous one - \b simplistic, \b low-poly \b artistic
	\b style. The trees are built from as few as 7 traingles, or even just 3 at
	the lowest level of detail (farthest distance from viewer). Similarly,
	buildings comprise of 10 or 14 triangles, depending on whether the building
	in particular has a slanted or a flat roof.
-	\b Backwards \b hardware \b compatbility. The game was intended to run on
	low-end (by modern standards) hardware. There have been reports of
	successful play on hardware as old as 6th generation NVIDIA GeForce GPUs.
	However, there is an outstanding performance issue on ATI/AMD hardware - the
	program runs extremely slowly, rendering the game unplayable. I haven't been
	able to track down the cause, though, as I do not have access to a machine
	I could debug it on.

In general, while working on the project, I was mainly focused on ensuring high
performance and relatively high (considering the procedural generation) quality
of visuals.

I also set priorities for the different parts of the project. In order to have
anything to display, I needed the content; thus, the content generator was the
module that received most attention in the initial stages of development. In
order to visualize the terrain generated by the algorithm, I created a simple
tool called \e terview, which is also included in the source tree. Once I had
the topographical data in the form of a heightmap, I moved on to the renderer,
and it wasn't until I had it draw a 1 square kilometre of terrain at a
reasonable speed that I started writing the game mechanics. 3D human models with
skeletal animation and an audio rendering engine were initially planned, but
were cut from the final game due to time constraints.

\section tools Tools
Since this project has been considerably larger and more complicated than the
previous ones, I resorted to outsourcing some of the tasks to different
libraries. The choices were made primarily on the cross-platform requirement
basis, but also my experience with the particular tool.

For the most noticeable part, the renderer, I used OpenGL, backed by SDL and
GLEW. They meet the cross-platform requirement and together form a good solid,
self-contained framework for modern OpenGL-based renderers. I've also had
experience with all of these libraries beforehand and felt pretty comfortable
with them. SDL provides synchronization, window manager event handling and user
input services, as well as platform-specific OpenGL rendering context
management, simplifying all of these tasks for my application and allowing my
code to be platform-agnostic. The GLEW library transparently handles OpenGL
extensions, which are otherwise awkward to use.

As for the development environment, I used the Code::Blocks IDE on Debian Linux
together with the GNU C Compiler in two flavours - the Linux-native and the
MinGW port (for Win32 cross-compilation). This toolset enabled me to efficiently
and effortlessly develop code that works on both platforms without modification.

Doxygen has been used to generate the documentation you are currently reading.

\if build_html
Next: \ref game

Previous: \ref intro
\endif
**/
